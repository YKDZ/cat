
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
 * This file exports the `TermRelation` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */

import type * as PJTG from '../pjtg';
import * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model TermRelation
 * 
 */
export type TermRelationModel = runtime.Types.Result.DefaultSelection<Prisma.$TermRelationPayload>

export type AggregateTermRelation = {
  _count: TermRelationCountAggregateOutputType | null
  _avg: TermRelationAvgAggregateOutputType | null
  _sum: TermRelationSumAggregateOutputType | null
  _min: TermRelationMinAggregateOutputType | null
  _max: TermRelationMaxAggregateOutputType | null
}

export type TermRelationAvgAggregateOutputType = {
  termId: number | null
  translationId: number | null
}

export type TermRelationSumAggregateOutputType = {
  termId: number | null
  translationId: number | null
}

export type TermRelationMinAggregateOutputType = {
  termId: number | null
  translationId: number | null
}

export type TermRelationMaxAggregateOutputType = {
  termId: number | null
  translationId: number | null
}

export type TermRelationCountAggregateOutputType = {
  termId: number
  translationId: number
  _all: number
}


export type TermRelationAvgAggregateInputType = {
  termId?: true
  translationId?: true
}

export type TermRelationSumAggregateInputType = {
  termId?: true
  translationId?: true
}

export type TermRelationMinAggregateInputType = {
  termId?: true
  translationId?: true
}

export type TermRelationMaxAggregateInputType = {
  termId?: true
  translationId?: true
}

export type TermRelationCountAggregateInputType = {
  termId?: true
  translationId?: true
  _all?: true
}

export type TermRelationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which TermRelation to aggregate.
   */
  where?: Prisma.TermRelationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TermRelations to fetch.
   */
  orderBy?: Prisma.TermRelationOrderByWithRelationInput | Prisma.TermRelationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.TermRelationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` TermRelations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TermRelations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned TermRelations
  **/
  _count?: true | TermRelationCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: TermRelationAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: TermRelationSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: TermRelationMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: TermRelationMaxAggregateInputType
}

export type GetTermRelationAggregateType<T extends TermRelationAggregateArgs> = {
      [P in keyof T & keyof AggregateTermRelation]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateTermRelation[P]>
    : Prisma.GetScalarType<T[P], AggregateTermRelation[P]>
}




export type TermRelationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.TermRelationWhereInput
  orderBy?: Prisma.TermRelationOrderByWithAggregationInput | Prisma.TermRelationOrderByWithAggregationInput[]
  by: Prisma.TermRelationScalarFieldEnum[] | Prisma.TermRelationScalarFieldEnum
  having?: Prisma.TermRelationScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: TermRelationCountAggregateInputType | true
  _avg?: TermRelationAvgAggregateInputType
  _sum?: TermRelationSumAggregateInputType
  _min?: TermRelationMinAggregateInputType
  _max?: TermRelationMaxAggregateInputType
}

export type TermRelationGroupByOutputType = {
  termId: number
  translationId: number
  _count: TermRelationCountAggregateOutputType | null
  _avg: TermRelationAvgAggregateOutputType | null
  _sum: TermRelationSumAggregateOutputType | null
  _min: TermRelationMinAggregateOutputType | null
  _max: TermRelationMaxAggregateOutputType | null
}

type GetTermRelationGroupByPayload<T extends TermRelationGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<TermRelationGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof TermRelationGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], TermRelationGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], TermRelationGroupByOutputType[P]>
      }
    >
  > 



export type TermRelationWhereInput = {
  AND?: Prisma.TermRelationWhereInput | Prisma.TermRelationWhereInput[]
  OR?: Prisma.TermRelationWhereInput[]
  NOT?: Prisma.TermRelationWhereInput | Prisma.TermRelationWhereInput[]
  termId?: Prisma.IntFilter<"TermRelation"> | number
  translationId?: Prisma.IntFilter<"TermRelation"> | number
  Term?: Prisma.XOR<Prisma.TermScalarRelationFilter, Prisma.TermWhereInput>
  Translation?: Prisma.XOR<Prisma.TermScalarRelationFilter, Prisma.TermWhereInput>
}

export type TermRelationOrderByWithRelationInput = {
  termId?: Prisma.SortOrder
  translationId?: Prisma.SortOrder
  Term?: Prisma.TermOrderByWithRelationInput
  Translation?: Prisma.TermOrderByWithRelationInput
}

export type TermRelationWhereUniqueInput = Prisma.AtLeast<{
  termId_translationId?: Prisma.TermRelationTermIdTranslationIdCompoundUniqueInput
  AND?: Prisma.TermRelationWhereInput | Prisma.TermRelationWhereInput[]
  OR?: Prisma.TermRelationWhereInput[]
  NOT?: Prisma.TermRelationWhereInput | Prisma.TermRelationWhereInput[]
  termId?: Prisma.IntFilter<"TermRelation"> | number
  translationId?: Prisma.IntFilter<"TermRelation"> | number
  Term?: Prisma.XOR<Prisma.TermScalarRelationFilter, Prisma.TermWhereInput>
  Translation?: Prisma.XOR<Prisma.TermScalarRelationFilter, Prisma.TermWhereInput>
}, "termId_translationId">

export type TermRelationOrderByWithAggregationInput = {
  termId?: Prisma.SortOrder
  translationId?: Prisma.SortOrder
  _count?: Prisma.TermRelationCountOrderByAggregateInput
  _avg?: Prisma.TermRelationAvgOrderByAggregateInput
  _max?: Prisma.TermRelationMaxOrderByAggregateInput
  _min?: Prisma.TermRelationMinOrderByAggregateInput
  _sum?: Prisma.TermRelationSumOrderByAggregateInput
}

export type TermRelationScalarWhereWithAggregatesInput = {
  AND?: Prisma.TermRelationScalarWhereWithAggregatesInput | Prisma.TermRelationScalarWhereWithAggregatesInput[]
  OR?: Prisma.TermRelationScalarWhereWithAggregatesInput[]
  NOT?: Prisma.TermRelationScalarWhereWithAggregatesInput | Prisma.TermRelationScalarWhereWithAggregatesInput[]
  termId?: Prisma.IntWithAggregatesFilter<"TermRelation"> | number
  translationId?: Prisma.IntWithAggregatesFilter<"TermRelation"> | number
}

export type TermRelationCreateInput = {
  Term: Prisma.TermCreateNestedOneWithoutTermRelationInput
  Translation: Prisma.TermCreateNestedOneWithoutTermTranslaitonRelationInput
}

export type TermRelationUncheckedCreateInput = {
  termId: number
  translationId: number
}

export type TermRelationUpdateInput = {
  Term?: Prisma.TermUpdateOneRequiredWithoutTermRelationNestedInput
  Translation?: Prisma.TermUpdateOneRequiredWithoutTermTranslaitonRelationNestedInput
}

export type TermRelationUncheckedUpdateInput = {
  termId?: Prisma.IntFieldUpdateOperationsInput | number
  translationId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type TermRelationCreateManyInput = {
  termId: number
  translationId: number
}

export type TermRelationUpdateManyMutationInput = {

}

export type TermRelationUncheckedUpdateManyInput = {
  termId?: Prisma.IntFieldUpdateOperationsInput | number
  translationId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type TermRelationListRelationFilter = {
  every?: Prisma.TermRelationWhereInput
  some?: Prisma.TermRelationWhereInput
  none?: Prisma.TermRelationWhereInput
}

export type TermRelationOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type TermRelationTermIdTranslationIdCompoundUniqueInput = {
  termId: number
  translationId: number
}

export type TermRelationCountOrderByAggregateInput = {
  termId?: Prisma.SortOrder
  translationId?: Prisma.SortOrder
}

export type TermRelationAvgOrderByAggregateInput = {
  termId?: Prisma.SortOrder
  translationId?: Prisma.SortOrder
}

export type TermRelationMaxOrderByAggregateInput = {
  termId?: Prisma.SortOrder
  translationId?: Prisma.SortOrder
}

export type TermRelationMinOrderByAggregateInput = {
  termId?: Prisma.SortOrder
  translationId?: Prisma.SortOrder
}

export type TermRelationSumOrderByAggregateInput = {
  termId?: Prisma.SortOrder
  translationId?: Prisma.SortOrder
}

export type TermRelationCreateNestedManyWithoutTermInput = {
  create?: Prisma.XOR<Prisma.TermRelationCreateWithoutTermInput, Prisma.TermRelationUncheckedCreateWithoutTermInput> | Prisma.TermRelationCreateWithoutTermInput[] | Prisma.TermRelationUncheckedCreateWithoutTermInput[]
  connectOrCreate?: Prisma.TermRelationCreateOrConnectWithoutTermInput | Prisma.TermRelationCreateOrConnectWithoutTermInput[]
  createMany?: Prisma.TermRelationCreateManyTermInputEnvelope
  connect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
}

export type TermRelationCreateNestedManyWithoutTranslationInput = {
  create?: Prisma.XOR<Prisma.TermRelationCreateWithoutTranslationInput, Prisma.TermRelationUncheckedCreateWithoutTranslationInput> | Prisma.TermRelationCreateWithoutTranslationInput[] | Prisma.TermRelationUncheckedCreateWithoutTranslationInput[]
  connectOrCreate?: Prisma.TermRelationCreateOrConnectWithoutTranslationInput | Prisma.TermRelationCreateOrConnectWithoutTranslationInput[]
  createMany?: Prisma.TermRelationCreateManyTranslationInputEnvelope
  connect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
}

export type TermRelationUncheckedCreateNestedManyWithoutTermInput = {
  create?: Prisma.XOR<Prisma.TermRelationCreateWithoutTermInput, Prisma.TermRelationUncheckedCreateWithoutTermInput> | Prisma.TermRelationCreateWithoutTermInput[] | Prisma.TermRelationUncheckedCreateWithoutTermInput[]
  connectOrCreate?: Prisma.TermRelationCreateOrConnectWithoutTermInput | Prisma.TermRelationCreateOrConnectWithoutTermInput[]
  createMany?: Prisma.TermRelationCreateManyTermInputEnvelope
  connect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
}

export type TermRelationUncheckedCreateNestedManyWithoutTranslationInput = {
  create?: Prisma.XOR<Prisma.TermRelationCreateWithoutTranslationInput, Prisma.TermRelationUncheckedCreateWithoutTranslationInput> | Prisma.TermRelationCreateWithoutTranslationInput[] | Prisma.TermRelationUncheckedCreateWithoutTranslationInput[]
  connectOrCreate?: Prisma.TermRelationCreateOrConnectWithoutTranslationInput | Prisma.TermRelationCreateOrConnectWithoutTranslationInput[]
  createMany?: Prisma.TermRelationCreateManyTranslationInputEnvelope
  connect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
}

export type TermRelationUpdateManyWithoutTermNestedInput = {
  create?: Prisma.XOR<Prisma.TermRelationCreateWithoutTermInput, Prisma.TermRelationUncheckedCreateWithoutTermInput> | Prisma.TermRelationCreateWithoutTermInput[] | Prisma.TermRelationUncheckedCreateWithoutTermInput[]
  connectOrCreate?: Prisma.TermRelationCreateOrConnectWithoutTermInput | Prisma.TermRelationCreateOrConnectWithoutTermInput[]
  upsert?: Prisma.TermRelationUpsertWithWhereUniqueWithoutTermInput | Prisma.TermRelationUpsertWithWhereUniqueWithoutTermInput[]
  createMany?: Prisma.TermRelationCreateManyTermInputEnvelope
  set?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  disconnect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  delete?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  connect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  update?: Prisma.TermRelationUpdateWithWhereUniqueWithoutTermInput | Prisma.TermRelationUpdateWithWhereUniqueWithoutTermInput[]
  updateMany?: Prisma.TermRelationUpdateManyWithWhereWithoutTermInput | Prisma.TermRelationUpdateManyWithWhereWithoutTermInput[]
  deleteMany?: Prisma.TermRelationScalarWhereInput | Prisma.TermRelationScalarWhereInput[]
}

export type TermRelationUpdateManyWithoutTranslationNestedInput = {
  create?: Prisma.XOR<Prisma.TermRelationCreateWithoutTranslationInput, Prisma.TermRelationUncheckedCreateWithoutTranslationInput> | Prisma.TermRelationCreateWithoutTranslationInput[] | Prisma.TermRelationUncheckedCreateWithoutTranslationInput[]
  connectOrCreate?: Prisma.TermRelationCreateOrConnectWithoutTranslationInput | Prisma.TermRelationCreateOrConnectWithoutTranslationInput[]
  upsert?: Prisma.TermRelationUpsertWithWhereUniqueWithoutTranslationInput | Prisma.TermRelationUpsertWithWhereUniqueWithoutTranslationInput[]
  createMany?: Prisma.TermRelationCreateManyTranslationInputEnvelope
  set?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  disconnect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  delete?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  connect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  update?: Prisma.TermRelationUpdateWithWhereUniqueWithoutTranslationInput | Prisma.TermRelationUpdateWithWhereUniqueWithoutTranslationInput[]
  updateMany?: Prisma.TermRelationUpdateManyWithWhereWithoutTranslationInput | Prisma.TermRelationUpdateManyWithWhereWithoutTranslationInput[]
  deleteMany?: Prisma.TermRelationScalarWhereInput | Prisma.TermRelationScalarWhereInput[]
}

export type TermRelationUncheckedUpdateManyWithoutTermNestedInput = {
  create?: Prisma.XOR<Prisma.TermRelationCreateWithoutTermInput, Prisma.TermRelationUncheckedCreateWithoutTermInput> | Prisma.TermRelationCreateWithoutTermInput[] | Prisma.TermRelationUncheckedCreateWithoutTermInput[]
  connectOrCreate?: Prisma.TermRelationCreateOrConnectWithoutTermInput | Prisma.TermRelationCreateOrConnectWithoutTermInput[]
  upsert?: Prisma.TermRelationUpsertWithWhereUniqueWithoutTermInput | Prisma.TermRelationUpsertWithWhereUniqueWithoutTermInput[]
  createMany?: Prisma.TermRelationCreateManyTermInputEnvelope
  set?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  disconnect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  delete?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  connect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  update?: Prisma.TermRelationUpdateWithWhereUniqueWithoutTermInput | Prisma.TermRelationUpdateWithWhereUniqueWithoutTermInput[]
  updateMany?: Prisma.TermRelationUpdateManyWithWhereWithoutTermInput | Prisma.TermRelationUpdateManyWithWhereWithoutTermInput[]
  deleteMany?: Prisma.TermRelationScalarWhereInput | Prisma.TermRelationScalarWhereInput[]
}

export type TermRelationUncheckedUpdateManyWithoutTranslationNestedInput = {
  create?: Prisma.XOR<Prisma.TermRelationCreateWithoutTranslationInput, Prisma.TermRelationUncheckedCreateWithoutTranslationInput> | Prisma.TermRelationCreateWithoutTranslationInput[] | Prisma.TermRelationUncheckedCreateWithoutTranslationInput[]
  connectOrCreate?: Prisma.TermRelationCreateOrConnectWithoutTranslationInput | Prisma.TermRelationCreateOrConnectWithoutTranslationInput[]
  upsert?: Prisma.TermRelationUpsertWithWhereUniqueWithoutTranslationInput | Prisma.TermRelationUpsertWithWhereUniqueWithoutTranslationInput[]
  createMany?: Prisma.TermRelationCreateManyTranslationInputEnvelope
  set?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  disconnect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  delete?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  connect?: Prisma.TermRelationWhereUniqueInput | Prisma.TermRelationWhereUniqueInput[]
  update?: Prisma.TermRelationUpdateWithWhereUniqueWithoutTranslationInput | Prisma.TermRelationUpdateWithWhereUniqueWithoutTranslationInput[]
  updateMany?: Prisma.TermRelationUpdateManyWithWhereWithoutTranslationInput | Prisma.TermRelationUpdateManyWithWhereWithoutTranslationInput[]
  deleteMany?: Prisma.TermRelationScalarWhereInput | Prisma.TermRelationScalarWhereInput[]
}

export type TermRelationCreateWithoutTermInput = {
  Translation: Prisma.TermCreateNestedOneWithoutTermTranslaitonRelationInput
}

export type TermRelationUncheckedCreateWithoutTermInput = {
  translationId: number
}

export type TermRelationCreateOrConnectWithoutTermInput = {
  where: Prisma.TermRelationWhereUniqueInput
  create: Prisma.XOR<Prisma.TermRelationCreateWithoutTermInput, Prisma.TermRelationUncheckedCreateWithoutTermInput>
}

export type TermRelationCreateManyTermInputEnvelope = {
  data: Prisma.TermRelationCreateManyTermInput | Prisma.TermRelationCreateManyTermInput[]
  skipDuplicates?: boolean
}

export type TermRelationCreateWithoutTranslationInput = {
  Term: Prisma.TermCreateNestedOneWithoutTermRelationInput
}

export type TermRelationUncheckedCreateWithoutTranslationInput = {
  termId: number
}

export type TermRelationCreateOrConnectWithoutTranslationInput = {
  where: Prisma.TermRelationWhereUniqueInput
  create: Prisma.XOR<Prisma.TermRelationCreateWithoutTranslationInput, Prisma.TermRelationUncheckedCreateWithoutTranslationInput>
}

export type TermRelationCreateManyTranslationInputEnvelope = {
  data: Prisma.TermRelationCreateManyTranslationInput | Prisma.TermRelationCreateManyTranslationInput[]
  skipDuplicates?: boolean
}

export type TermRelationUpsertWithWhereUniqueWithoutTermInput = {
  where: Prisma.TermRelationWhereUniqueInput
  update: Prisma.XOR<Prisma.TermRelationUpdateWithoutTermInput, Prisma.TermRelationUncheckedUpdateWithoutTermInput>
  create: Prisma.XOR<Prisma.TermRelationCreateWithoutTermInput, Prisma.TermRelationUncheckedCreateWithoutTermInput>
}

export type TermRelationUpdateWithWhereUniqueWithoutTermInput = {
  where: Prisma.TermRelationWhereUniqueInput
  data: Prisma.XOR<Prisma.TermRelationUpdateWithoutTermInput, Prisma.TermRelationUncheckedUpdateWithoutTermInput>
}

export type TermRelationUpdateManyWithWhereWithoutTermInput = {
  where: Prisma.TermRelationScalarWhereInput
  data: Prisma.XOR<Prisma.TermRelationUpdateManyMutationInput, Prisma.TermRelationUncheckedUpdateManyWithoutTermInput>
}

export type TermRelationScalarWhereInput = {
  AND?: Prisma.TermRelationScalarWhereInput | Prisma.TermRelationScalarWhereInput[]
  OR?: Prisma.TermRelationScalarWhereInput[]
  NOT?: Prisma.TermRelationScalarWhereInput | Prisma.TermRelationScalarWhereInput[]
  termId?: Prisma.IntFilter<"TermRelation"> | number
  translationId?: Prisma.IntFilter<"TermRelation"> | number
}

export type TermRelationUpsertWithWhereUniqueWithoutTranslationInput = {
  where: Prisma.TermRelationWhereUniqueInput
  update: Prisma.XOR<Prisma.TermRelationUpdateWithoutTranslationInput, Prisma.TermRelationUncheckedUpdateWithoutTranslationInput>
  create: Prisma.XOR<Prisma.TermRelationCreateWithoutTranslationInput, Prisma.TermRelationUncheckedCreateWithoutTranslationInput>
}

export type TermRelationUpdateWithWhereUniqueWithoutTranslationInput = {
  where: Prisma.TermRelationWhereUniqueInput
  data: Prisma.XOR<Prisma.TermRelationUpdateWithoutTranslationInput, Prisma.TermRelationUncheckedUpdateWithoutTranslationInput>
}

export type TermRelationUpdateManyWithWhereWithoutTranslationInput = {
  where: Prisma.TermRelationScalarWhereInput
  data: Prisma.XOR<Prisma.TermRelationUpdateManyMutationInput, Prisma.TermRelationUncheckedUpdateManyWithoutTranslationInput>
}

export type TermRelationCreateManyTermInput = {
  translationId: number
}

export type TermRelationCreateManyTranslationInput = {
  termId: number
}

export type TermRelationUpdateWithoutTermInput = {
  Translation?: Prisma.TermUpdateOneRequiredWithoutTermTranslaitonRelationNestedInput
}

export type TermRelationUncheckedUpdateWithoutTermInput = {
  translationId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type TermRelationUncheckedUpdateManyWithoutTermInput = {
  translationId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type TermRelationUpdateWithoutTranslationInput = {
  Term?: Prisma.TermUpdateOneRequiredWithoutTermRelationNestedInput
}

export type TermRelationUncheckedUpdateWithoutTranslationInput = {
  termId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type TermRelationUncheckedUpdateManyWithoutTranslationInput = {
  termId?: Prisma.IntFieldUpdateOperationsInput | number
}



export type TermRelationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  termId?: boolean
  translationId?: boolean
  Term?: boolean | Prisma.TermDefaultArgs<ExtArgs>
  Translation?: boolean | Prisma.TermDefaultArgs<ExtArgs>
}, ExtArgs["result"]["termRelation"]>

export type TermRelationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  termId?: boolean
  translationId?: boolean
  Term?: boolean | Prisma.TermDefaultArgs<ExtArgs>
  Translation?: boolean | Prisma.TermDefaultArgs<ExtArgs>
}, ExtArgs["result"]["termRelation"]>

export type TermRelationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  termId?: boolean
  translationId?: boolean
  Term?: boolean | Prisma.TermDefaultArgs<ExtArgs>
  Translation?: boolean | Prisma.TermDefaultArgs<ExtArgs>
}, ExtArgs["result"]["termRelation"]>

export type TermRelationSelectScalar = {
  termId?: boolean
  translationId?: boolean
}

export type TermRelationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"termId" | "translationId", ExtArgs["result"]["termRelation"]>
export type TermRelationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  Term?: boolean | Prisma.TermDefaultArgs<ExtArgs>
  Translation?: boolean | Prisma.TermDefaultArgs<ExtArgs>
}
export type TermRelationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  Term?: boolean | Prisma.TermDefaultArgs<ExtArgs>
  Translation?: boolean | Prisma.TermDefaultArgs<ExtArgs>
}
export type TermRelationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  Term?: boolean | Prisma.TermDefaultArgs<ExtArgs>
  Translation?: boolean | Prisma.TermDefaultArgs<ExtArgs>
}

export type $TermRelationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "TermRelation"
  objects: {
    Term: Prisma.$TermPayload<ExtArgs>
    Translation: Prisma.$TermPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    termId: number
    translationId: number
  }, ExtArgs["result"]["termRelation"]>
  composites: {}
}

export type TermRelationGetPayload<S extends boolean | null | undefined | TermRelationDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$TermRelationPayload, S>

export type TermRelationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<TermRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TermRelationCountAggregateInputType | true
  }

export interface TermRelationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TermRelation'], meta: { name: 'TermRelation' } }
  /**
   * Find zero or one TermRelation that matches the filter.
   * @param {TermRelationFindUniqueArgs} args - Arguments to find a TermRelation
   * @example
   * // Get one TermRelation
   * const termRelation = await prisma.termRelation.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends TermRelationFindUniqueArgs>(args: Prisma.SelectSubset<T, TermRelationFindUniqueArgs<ExtArgs>>): Prisma.Prisma__TermRelationClient<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one TermRelation that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {TermRelationFindUniqueOrThrowArgs} args - Arguments to find a TermRelation
   * @example
   * // Get one TermRelation
   * const termRelation = await prisma.termRelation.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends TermRelationFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, TermRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__TermRelationClient<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first TermRelation that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermRelationFindFirstArgs} args - Arguments to find a TermRelation
   * @example
   * // Get one TermRelation
   * const termRelation = await prisma.termRelation.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends TermRelationFindFirstArgs>(args?: Prisma.SelectSubset<T, TermRelationFindFirstArgs<ExtArgs>>): Prisma.Prisma__TermRelationClient<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first TermRelation that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermRelationFindFirstOrThrowArgs} args - Arguments to find a TermRelation
   * @example
   * // Get one TermRelation
   * const termRelation = await prisma.termRelation.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends TermRelationFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, TermRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__TermRelationClient<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more TermRelations that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermRelationFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all TermRelations
   * const termRelations = await prisma.termRelation.findMany()
   * 
   * // Get first 10 TermRelations
   * const termRelations = await prisma.termRelation.findMany({ take: 10 })
   * 
   * // Only select the `termId`
   * const termRelationWithTermIdOnly = await prisma.termRelation.findMany({ select: { termId: true } })
   * 
   */
  findMany<T extends TermRelationFindManyArgs>(args?: Prisma.SelectSubset<T, TermRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a TermRelation.
   * @param {TermRelationCreateArgs} args - Arguments to create a TermRelation.
   * @example
   * // Create one TermRelation
   * const TermRelation = await prisma.termRelation.create({
   *   data: {
   *     // ... data to create a TermRelation
   *   }
   * })
   * 
   */
  create<T extends TermRelationCreateArgs>(args: Prisma.SelectSubset<T, TermRelationCreateArgs<ExtArgs>>): Prisma.Prisma__TermRelationClient<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many TermRelations.
   * @param {TermRelationCreateManyArgs} args - Arguments to create many TermRelations.
   * @example
   * // Create many TermRelations
   * const termRelation = await prisma.termRelation.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends TermRelationCreateManyArgs>(args?: Prisma.SelectSubset<T, TermRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many TermRelations and returns the data saved in the database.
   * @param {TermRelationCreateManyAndReturnArgs} args - Arguments to create many TermRelations.
   * @example
   * // Create many TermRelations
   * const termRelation = await prisma.termRelation.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many TermRelations and only return the `termId`
   * const termRelationWithTermIdOnly = await prisma.termRelation.createManyAndReturn({
   *   select: { termId: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends TermRelationCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, TermRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a TermRelation.
   * @param {TermRelationDeleteArgs} args - Arguments to delete one TermRelation.
   * @example
   * // Delete one TermRelation
   * const TermRelation = await prisma.termRelation.delete({
   *   where: {
   *     // ... filter to delete one TermRelation
   *   }
   * })
   * 
   */
  delete<T extends TermRelationDeleteArgs>(args: Prisma.SelectSubset<T, TermRelationDeleteArgs<ExtArgs>>): Prisma.Prisma__TermRelationClient<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one TermRelation.
   * @param {TermRelationUpdateArgs} args - Arguments to update one TermRelation.
   * @example
   * // Update one TermRelation
   * const termRelation = await prisma.termRelation.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends TermRelationUpdateArgs>(args: Prisma.SelectSubset<T, TermRelationUpdateArgs<ExtArgs>>): Prisma.Prisma__TermRelationClient<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more TermRelations.
   * @param {TermRelationDeleteManyArgs} args - Arguments to filter TermRelations to delete.
   * @example
   * // Delete a few TermRelations
   * const { count } = await prisma.termRelation.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends TermRelationDeleteManyArgs>(args?: Prisma.SelectSubset<T, TermRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more TermRelations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermRelationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many TermRelations
   * const termRelation = await prisma.termRelation.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends TermRelationUpdateManyArgs>(args: Prisma.SelectSubset<T, TermRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more TermRelations and returns the data updated in the database.
   * @param {TermRelationUpdateManyAndReturnArgs} args - Arguments to update many TermRelations.
   * @example
   * // Update many TermRelations
   * const termRelation = await prisma.termRelation.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more TermRelations and only return the `termId`
   * const termRelationWithTermIdOnly = await prisma.termRelation.updateManyAndReturn({
   *   select: { termId: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends TermRelationUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, TermRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one TermRelation.
   * @param {TermRelationUpsertArgs} args - Arguments to update or create a TermRelation.
   * @example
   * // Update or create a TermRelation
   * const termRelation = await prisma.termRelation.upsert({
   *   create: {
   *     // ... data to create a TermRelation
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the TermRelation we want to update
   *   }
   * })
   */
  upsert<T extends TermRelationUpsertArgs>(args: Prisma.SelectSubset<T, TermRelationUpsertArgs<ExtArgs>>): Prisma.Prisma__TermRelationClient<runtime.Types.Result.GetResult<Prisma.$TermRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of TermRelations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermRelationCountArgs} args - Arguments to filter TermRelations to count.
   * @example
   * // Count the number of TermRelations
   * const count = await prisma.termRelation.count({
   *   where: {
   *     // ... the filter for the TermRelations we want to count
   *   }
   * })
  **/
  count<T extends TermRelationCountArgs>(
    args?: Prisma.Subset<T, TermRelationCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], TermRelationCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a TermRelation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends TermRelationAggregateArgs>(args: Prisma.Subset<T, TermRelationAggregateArgs>): Prisma.PrismaPromise<GetTermRelationAggregateType<T>>

  /**
   * Group by TermRelation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermRelationGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends TermRelationGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: TermRelationGroupByArgs['orderBy'] }
      : { orderBy?: TermRelationGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, TermRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the TermRelation model
 */
readonly fields: TermRelationFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for TermRelation.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__TermRelationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  Term<T extends Prisma.TermDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TermDefaultArgs<ExtArgs>>): Prisma.Prisma__TermClient<runtime.Types.Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  Translation<T extends Prisma.TermDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TermDefaultArgs<ExtArgs>>): Prisma.Prisma__TermClient<runtime.Types.Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the TermRelation model
 */
export interface TermRelationFieldRefs {
  readonly termId: Prisma.FieldRef<"TermRelation", 'Int'>
  readonly translationId: Prisma.FieldRef<"TermRelation", 'Int'>
}
    

// Custom InputTypes
/**
 * TermRelation findUnique
 */
export type TermRelationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
  /**
   * Filter, which TermRelation to fetch.
   */
  where: Prisma.TermRelationWhereUniqueInput
}

/**
 * TermRelation findUniqueOrThrow
 */
export type TermRelationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
  /**
   * Filter, which TermRelation to fetch.
   */
  where: Prisma.TermRelationWhereUniqueInput
}

/**
 * TermRelation findFirst
 */
export type TermRelationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
  /**
   * Filter, which TermRelation to fetch.
   */
  where?: Prisma.TermRelationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TermRelations to fetch.
   */
  orderBy?: Prisma.TermRelationOrderByWithRelationInput | Prisma.TermRelationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for TermRelations.
   */
  cursor?: Prisma.TermRelationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` TermRelations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TermRelations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of TermRelations.
   */
  distinct?: Prisma.TermRelationScalarFieldEnum | Prisma.TermRelationScalarFieldEnum[]
}

/**
 * TermRelation findFirstOrThrow
 */
export type TermRelationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
  /**
   * Filter, which TermRelation to fetch.
   */
  where?: Prisma.TermRelationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TermRelations to fetch.
   */
  orderBy?: Prisma.TermRelationOrderByWithRelationInput | Prisma.TermRelationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for TermRelations.
   */
  cursor?: Prisma.TermRelationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` TermRelations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TermRelations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of TermRelations.
   */
  distinct?: Prisma.TermRelationScalarFieldEnum | Prisma.TermRelationScalarFieldEnum[]
}

/**
 * TermRelation findMany
 */
export type TermRelationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
  /**
   * Filter, which TermRelations to fetch.
   */
  where?: Prisma.TermRelationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TermRelations to fetch.
   */
  orderBy?: Prisma.TermRelationOrderByWithRelationInput | Prisma.TermRelationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing TermRelations.
   */
  cursor?: Prisma.TermRelationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` TermRelations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TermRelations.
   */
  skip?: number
  distinct?: Prisma.TermRelationScalarFieldEnum | Prisma.TermRelationScalarFieldEnum[]
}

/**
 * TermRelation create
 */
export type TermRelationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
  /**
   * The data needed to create a TermRelation.
   */
  data: Prisma.XOR<Prisma.TermRelationCreateInput, Prisma.TermRelationUncheckedCreateInput>
}

/**
 * TermRelation createMany
 */
export type TermRelationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many TermRelations.
   */
  data: Prisma.TermRelationCreateManyInput | Prisma.TermRelationCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * TermRelation createManyAndReturn
 */
export type TermRelationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * The data used to create many TermRelations.
   */
  data: Prisma.TermRelationCreateManyInput | Prisma.TermRelationCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * TermRelation update
 */
export type TermRelationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
  /**
   * The data needed to update a TermRelation.
   */
  data: Prisma.XOR<Prisma.TermRelationUpdateInput, Prisma.TermRelationUncheckedUpdateInput>
  /**
   * Choose, which TermRelation to update.
   */
  where: Prisma.TermRelationWhereUniqueInput
}

/**
 * TermRelation updateMany
 */
export type TermRelationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update TermRelations.
   */
  data: Prisma.XOR<Prisma.TermRelationUpdateManyMutationInput, Prisma.TermRelationUncheckedUpdateManyInput>
  /**
   * Filter which TermRelations to update
   */
  where?: Prisma.TermRelationWhereInput
  /**
   * Limit how many TermRelations to update.
   */
  limit?: number
}

/**
 * TermRelation updateManyAndReturn
 */
export type TermRelationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * The data used to update TermRelations.
   */
  data: Prisma.XOR<Prisma.TermRelationUpdateManyMutationInput, Prisma.TermRelationUncheckedUpdateManyInput>
  /**
   * Filter which TermRelations to update
   */
  where?: Prisma.TermRelationWhereInput
  /**
   * Limit how many TermRelations to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * TermRelation upsert
 */
export type TermRelationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
  /**
   * The filter to search for the TermRelation to update in case it exists.
   */
  where: Prisma.TermRelationWhereUniqueInput
  /**
   * In case the TermRelation found by the `where` argument doesn't exist, create a new TermRelation with this data.
   */
  create: Prisma.XOR<Prisma.TermRelationCreateInput, Prisma.TermRelationUncheckedCreateInput>
  /**
   * In case the TermRelation was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.TermRelationUpdateInput, Prisma.TermRelationUncheckedUpdateInput>
}

/**
 * TermRelation delete
 */
export type TermRelationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
  /**
   * Filter which TermRelation to delete.
   */
  where: Prisma.TermRelationWhereUniqueInput
}

/**
 * TermRelation deleteMany
 */
export type TermRelationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which TermRelations to delete
   */
  where?: Prisma.TermRelationWhereInput
  /**
   * Limit how many TermRelations to delete.
   */
  limit?: number
}

/**
 * TermRelation without action
 */
export type TermRelationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TermRelation
   */
  select?: Prisma.TermRelationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TermRelation
   */
  omit?: Prisma.TermRelationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermRelationInclude<ExtArgs> | null
}
